# 主从复制
## 参考
[Redis 核心技术与实战](https://time.geekbang.org/column/intro/100056701)

[小林coding redis](https://www.xiaolincoding.com/redis/cluster/master_slave_replication.html)

## 原理
启用多台服务器，使用一主多从的结构，将数据备份到每一台服务器上。

目的：分摊主服务器压力、提高可用性

主从复制共有三种模式：全**量复制、基于长连接的命令传播、增量复制**。

### 单点模式面临的问题：
* 所有请求都由一台机器处理，压力过大
* 服务器宕机导致服务不可用

### 主从复制模式优势：
* 读写分离。主库处理写请求，从库负责读。
* 一台服务器宕机不会影响整体服务

### 主从复制模式问题：
* 数据一致性问题（同步机制）
* 需要考虑故障转移（哨兵机制）

## 全量复制（初次同步）
初次同步三阶段：建立连接、同步数据、查漏补缺
![同步三阶段](https://cdn.xiaolincoding.com//mysql/other/ea4f7e86baf2435af3999e5cd38b6a26.png)

### 建立连接
命令： `replicaof 192.168.1.1 6379` 

执行该命令将当前实例变成指定ip:host实例的从库。

网络层面看，当前实例给主服务器发送`psync`同步请求（`psync ? -1` ?表示未知的主库runID，-1表示第一次复制），主服务器收到后会返回`FULLRESYNC`全量复制命令响应，同时会携带`runID`（redis实例id）和`offset`（复制进度）

连接建立以后，就准备进入全量复制阶段了。

### 同步数据
主库通过`bgsave`命令通过fork出的子进程**异步**生成RDB文件，然后将文件发给从库。从库收到后，先清空当前数据库，然后加载RDB文件，为了避免**从库中之前数据的影响**。

#### 主从数据一致性问题
存在三个时间段，会导致新收到的写命令不会同步给从库：
1. 主库生成RDB文件期间
2. 主库发送RDB文件期间
3. 从库加载RDB文件期间

如果不进行特殊处理，数据库中数据越多RDB文件越大，导致的不一致情况也会越严重。

* 解决办法：使用 `replication buffer` 缓冲区

在RDB发送过程中，将所有新增到的写命令记录到该缓冲区中，在收到从库的全量复制完成信号后，就进入第三阶段，复制缓冲区中的命令。

### 查漏补缺
主库将`replication buffer`中的所有记录发送给从库，至此，主从之间的第一次同步就完成了。

## 基于长连接的命令传播
在主从库完成第一次同步后，双方之间维护一个TCP**长连接**，目的是避免频繁的断开和连接带来的性能开销。

当主库收到写操作时，会通过长连接传播给从库。

## 增量复制
当主从库之间出现了网络问题，如何同步网络断连期间主库新增的写命令？
1. 重新进行全量复制（redis 2.8以前），开销很大
2. 增量复制（目前采用的方法）

网络恢复后如何确定断开期间主库增量的数据？`repl_backlog_buffer`环形缓冲区。
### repl_backlog_buffer
`repl_backlog_buffer`是一个大小可指定的环形缓冲区，写操作不仅会写入 `replication buffer`，还会写入该环形缓冲区。主库和从库分别维护自己写到或读到的位置。

当主从库之间的连接重新建立后，从库会发送`psync`命令请求同步，其中会携带复制进度offset。主库从而可以根据自己的offset和从库的offset判断断线期间新增的写命令有哪些，然后依次同步给从库。

如果主库判断offset时发现从库要读取的数据已经被覆盖了，那么就会采用全量同步。

ps：环形缓冲区写满后，继续写入会覆盖掉之前的数据。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。

解决：调整缓冲区大小

## 总结
主从复制三阶段、主从网络延迟的数据一致性保证

问题：主库故障或断连，如何保证服务可靠性？

解决：哨兵集群