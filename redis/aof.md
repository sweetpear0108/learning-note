# 持久化之AOF日志
## 参考
## 参考
[Redis 核心技术与实战](https://time.geekbang.org/column/intro/100056701)

[小林coding redis](https://www.xiaolincoding.com/redis/storage/aof.html)

## 定义
* AOF：Append Only File

保存**写**命令到日志，当数据需要恢复时执行aof文件中记录的所有写操作命令。

## 特点
### 写后日志
Redis先执行命令把数据写入内存，然后再记录日志

优点：
1. 避免额外的检查开销
2. 不会阻塞当前写命令的执行

缺点
1. 数据可能因为宕机丢失
2. 可能阻塞下一个命令

### 文本形式保存
命令`set k v`在aof文件中的表现形式：
```
*3  --> 单词数
$3  --> 字符数
set
$1
k
$1
v
```

优点：
1. 可读性强，方便调试
2. 容错性更强，一部分数据损坏不会影响整个文件的解析

缺点：
1. 空间占用较大
2. 存在冗余记录（需要重写）

## 写回策略
写回：写入磁盘

### 三种写回策略
在配置文件中`appendfsync`可填写**三种**参数：Always, Everysec, No， 三种策略是对于**主进程阻塞**和**减少数据丢失**两个问题的取舍。

![三种策略](https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a.png)

### aof写入流程
```执行写命令 -> 写到用户态aof缓冲区 -> 发起I/O系统调用write()将aof缓冲区数据拷贝到内核缓冲区page cache -> 排入队列，由内核决定何时写入磁盘```

由此可见，性能瓶颈集中在write系统调用将数据拷贝到系统缓冲区步骤上，在此期间主进程会被阻塞。

操作系统的`fsync()`系统调用可以立即将内核缓冲区中的数据写入磁盘，三种写入策略对应着三种fsync的调用时机：
* Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；
* Everysec 策略就会创建一个异步任务来执行 fsync() 函数；
* No 策略就是永不执行 fsync() 函数;

ps：为什么不使用多线程？ 因为多线程需要涉及共享资源的并发控制，实现复杂且会有性能损耗。

## 重写机制
当aof文件过大时（默认64MB），会从主进程fork出一个子**进程**，在后台进行aof的重写。

重写过程：
1. 子进程扫描数据库中（内存Redis数据）所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。
2. 向主进程发送一条信号表示转换完成，主进程收到信号后通过信号处理函数将aof**重写缓冲**区中的内容追加到新的aof文件中。
3. 主进程对新的aof文件进行改名，覆盖现有的aof文件。

![重写](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Redis%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/assets/6b054eb1aed0734bd81ddab9a31d0be8-20221015222953-4ennczi.jpg)

### fork
**fork出子进程而不是子线程**

多线程间会共享内存，当修改共享内存中的数据时就需要**加锁**来保证数据安全，造成性能的降低。

而子进程会复制主进程的**页表**（记录着虚拟地址和物理地址映射关系），而不是物理内存中的所有数据，并且子进程对这个共享的内存拥有**只读**的权限，当父子进程任意一方进行修改时，就会发生**写时复制**。

* 目的：提升性能，减少fork过程阻塞时间

### 写时复制
在发生写操作的时候，操作系统才会去复制物理内存中**要被修改**的这块数据，生成该数据的副本。然后在这个数据副本上进行修改。

![COW](https://cdn.xiaolincoding.com//mysql/other/d4cfac545377b54dd035c775603b4936.png)

* 目的：节约物理内存资源

### 重写期间有数据被修改了，导致父子进程redis数据不一致的问题
解决办法：启用**aof重写缓冲区**

redis内存中设置了重写缓冲区，当子进程创建以后开始使用。

当主进程执行完一个写命令之后，会**同时**将这个写命令写入到**AOF缓冲区**和**AOF重写缓冲区**。

* 双写的目的：保证重写失败依旧拥有完整aof日志，保证重写期间的修改操作不会遗漏。

## 总结
aof写回 -> 主进程     aof重写 -> 子进程

阻塞时机：
1. fork子进程时，取决于页表大小
2. 发生写时复制，取决于修改的数据对应的物理内存的大小
3. 追加重写缓冲区中的数据时，取决于数据大小
4. 文件重命名，覆盖现有aof文件时

缺点：
1. 恢复时需要重新执行所有记录，速度较慢