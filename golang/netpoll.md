# I/O模型和网络轮询器netpoll
## 参考
[Java并发之BIO NIO AIO IO多路复用的区别](https://blog.csdn.net/u014453898/article/details/109811000)

[网络轮询器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/)

[小林coding](https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#epoll)

[面试官：请你谈谈关于IO同步、异步、阻塞、非阻塞的区别？](https://blog.csdn.net/pisa8559/article/details/130962402)

## 五种I/O模型
同步阻塞 I/O（BIO）、同步非阻塞 I/O（NIO）、信号驱动 I/O（SIGIO）、异步非阻塞 I/O（AIO） 、I/O 多路复用（I/O multiplexing）

* I/O两阶段：等待数据准备、将数据从内核（用户程序）拷贝到用户程序（内核），见下图；

* 阻塞/非阻塞：线程在`资源就绪`之前是否需要等待
* 同步/异步：请求线程在`数据用户态内核态之间的拷贝`期间是否被阻塞

![五种](https://img-blog.csdnimg.cn/img_convert/91dbb51923d2532b1079a08c6aa3e0bd.png)

### 同步阻塞I/O（BIO）
最常见的IO模式，例如读写文件时执行read write系统调用。

从开始执行系统调用开始，用户线程就会进入阻塞状态直到I/O操作结束。

* 优点：简单，线程等待期间基本不会占用CPU资源
* 缺点：高并发下大量线程被阻塞，导致内存和线程切换开销巨大

### 同步非阻塞I/O（NIO）
用户程序会不断轮询发起系统调用，直到内核中资源准备就绪，再完成I/O操作。

* 优点：可以在等待过程中执行其他任务，提高 CPU 利用率
* 缺点：需要不断轮询占用大量 CPU 时间，且轮询间隔可能会放大响应延迟，降低整体数据吞吐量

### 异步非阻塞I/O（AIO）
用户线程只需要负责向内核发送一个系统调用请求，等待数据就绪和数据拷贝的过程都由内核来完成，完成后内核通过信号或回调函数通知用户线程I/O操作完成。

* 优点：减少了 NIO 中轮询占用的 CPU 资源，且减少了响应延迟
* 缺点：复杂，回调函数占用系统资源，使用信号通信多平台可移植性差

### 多路复用
**事件驱动**机制，使用特定的系统调用（select、poll、epoll等）阻塞地监听一组文件描述符，当文件描述符就绪（状态转变为可读或者可写）时，通知程序继续进行相应的I/O操作。

多路复用也属于同步策略，与NIO比较类似，只不过是由特定的系统调用负责去轮询资源是否就绪，而不是用户线程亲力亲为

为什么属于同步策略：特定系统调用只负责告诉用户程序资源是否就绪，而（在read调用中）数据从内核复制到用户内存的操作还是由用户程序发送系统调用触发

为什么可以处理大量连接：NIO一个请求需要一个线程去处理，而多路复用则是做到了**多路**请求**复用**一个线程，大大减少了资源占用

* 优点：可以同时处理大量连接，减小系统开销，响应性能好
* 缺点：select和poll都使用**线性结构**（数组和链表）存储文件描述符，需要拷贝到内核内存开销大，返回就绪事件需要遍历时间复杂度高，select还有数组大小限制

此外，由于特定系统调用是轮询的并且拷贝数据的时候用户线程也是阻塞的，所以多路复用只有在处理高并发请求的时候才能体现性能优势。

#### epoll
epoll解决了select、poll存在的内存开销和时间复杂度问题

* epoll使用**红黑树**的数据结构追踪所有待检测的文件描述符，每次只需要加入一个待检测的文件描述符，而不像select、poll一样每次操作都穿入整个集合，加入时间复杂度O(logn)

* 维护wait**链表**来记录就绪事件，而不是遍历整个集合

![epoll](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png)

#### 事件驱动
* 边缘触发：当被监控的文件描述符上第一次出现事件就绪时，通知用户程序
* 水平触发：当被监控的文件描述符上存在就绪事件，通知用户程序